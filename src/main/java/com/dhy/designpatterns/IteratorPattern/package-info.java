/**
 * @Title package-info
 * @Description
 *迭代器是一种行为设计模式，
 * 　让你能在不暴露集合底层表　
 * 　现形式（列表、栈和树等）　
 * 　的情况下遍历集合中所有的　
 * 　元素
 *
 *
 * 迭代器模式的主要思想是将集合的遍历行为抽取为单独的迭
 * 代器对象。
 *
 * 迭代器通常会提供一个获取集合元素的基本方法。客户端可
 * 不断调用该方法直至它不返回任何内容，这意味着迭代器已
 * 经遍历了所有元素。
 * 所有迭代器必须实现相同的接口。这样一来，只要有合适的
 * 迭代器， 客户端代码就能兼容任何类型的集合或遍历算法。
 * 如果你需要采用特殊方式来遍历集合，只需创建一个新的迭
 * 代器类即可，无需对集合或客户端进行修改。
 *
 *
 * 1. 迭代器（Iterator）接口声明了遍历集合所需的操作：获取下
 * 一个元素、获取当前位置和重新开始迭代等。
 * 2. 具体迭代器（Concrete Iterators）实现遍历集合的一种特定
 * 算法。迭代器对象必须跟踪自身遍历的进度。这使得多个迭
 * 代器可以相互独立地遍历同一集合。
 * 3. 集合（Collection）接口声明一个或多个方法来获取与集合兼
 * 容的迭代器。请注意，返回方法的类型必须被声明为迭代器
 * 接口，因此具体集合可以返回各种不同种类的迭代器。
 * 4. 具体集合（Concrete Collections）会在客户端请求迭代器时
 * 返回一个特定的具体迭代器类实体。你可能会琢磨，剩下的
 * 集合代码在什么地方呢？不用担心，它也会在同一个类中。
 * 只是这些细节对于实际模式来说并不重要，所以我们将其省
 * 略了而已。
 * 5. 客户端（Client）通过集合和迭代器的接口与两者进行交互。
 * 这样一来客户端无需与具体类进行耦合，允许同一客户端代
 * 码使用各种不同的集合和迭代器。
 * 客户端通常不会自行创建迭代器，而是会从集合中获取。但
 * 在特定情况下，客户端可以直接创建一个迭代器（例如当客
 * 户端需要自定义特殊迭代器时）。
 *
 *
 * @Author lvaolin
 * @Date 2022/1/27 10:31
 **/
package com.dhy.designpatterns.IteratorPattern;